testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_1.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (Let 'x (Bool #t) (Int 42)))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Let 'x (Bool #t) (Int 42)))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Let 'x20831 (Bool #t) (Int 42)))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Let 'x20831 (Bool #t) (Int 42)))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list (cons 'start (Seq (Assign (Var 'x20831) (Bool #t)) (Return (Int 42))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20831 . Boolean)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 1) (Var 'x20831)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20831 . Boolean)))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Var 'x20831)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20831 . Boolean)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Var 'x20831)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20831>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20831> . #<set:>))
old and updated-move-bias: 
((#<Var: x20831> . 0))
((#<Var: x20831> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: x20831> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20831 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

(start)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20831 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20831 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20831 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_start:
	movq	$1, %rcx
	movq	$42, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_2.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (Let 'x (Bool #f) (Int 42)))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Let 'x (Bool #f) (Int 42)))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Let 'x20832 (Bool #f) (Int 42)))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Let 'x20832 (Bool #f) (Int 42)))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list (cons 'start (Seq (Assign (Var 'x20832) (Bool #f)) (Return (Int 42))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20832 . Boolean)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 0) (Var 'x20832)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20832 . Boolean)))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 0) (Var 'x20832)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20832 . Boolean)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 0) (Var 'x20832)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20832>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20832> . #<set:>))
old and updated-move-bias: 
((#<Var: x20832> . 0))
((#<Var: x20832> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: x20832> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20832 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 0) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

(start)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20832 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 0) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20832 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 0) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20832 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'movq (list (Imm 0) (Reg 'rcx)))
     (Instr 'movq (list (Imm 42) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_start:
	movq	$0, %rcx
	movq	$42, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_3.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (If (Bool #t) (Int 42) (Int 0)))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (If (Bool #t) (Int 42) (Int 0)))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (If (Bool #t) (Int 42) (Int 0)))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (If (Bool #t) (Int 42) (Int 0)))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram '() (list (cons 'start (Return (Int 42)))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'start
   (Block
    '()
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

(start)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 42) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_start:
	movq	$42, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_4.rkt"


type-check: Integer != Boolean
in (If (Int 10) (Int 15) (Int 20))

compile-file: output of type check @ utilities.rkt:2105
tsexp:
#f


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_5.rkt"


type-check: Boolean != Integer
in (If (Var 'x) (Var 'x) (Int 10))

compile-file: output of type check @ utilities.rkt:2105
tsexp:
#f


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_6.rkt"


type-check: Integer != Boolean
in (If (Prim 'read '()) (Int 1) (Int 2))

compile-file: output of type check @ utilities.rkt:2105
tsexp:
#f


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_7.rkt"


type-check: Boolean != Integer
in (Prim '+ (list (Bool #t) (Int 1)))

compile-file: output of type check @ utilities.rkt:2105
tsexp:
#f


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_8.rkt"


type-check: Integer != Boolean
in (Prim 'not (list (Int 10)))

compile-file: output of type check @ utilities.rkt:2105
tsexp:
#f


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_9.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (If (Bool #f) (Int 15) (Int 20)))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (If (Bool #f) (Int 15) (Int 20)))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (If (Bool #f) (Int 15) (Int 20)))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (If (Bool #f) (Int 15) (Int 20)))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram '() (list (cons 'start (Return (Int 20)))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'start
   (Block
    '()
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

(start)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 20) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_start:
	movq	$20, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_90.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Let
  'x
  (If
   (Let 'x (Bool #t) (If (Var 'x) (Var 'x) (Prim 'not (list (Var 'x)))))
   (Bool #t)
   (Bool #f))
  (If (Var 'x) (Int 10) (Prim '- (list (Int 10))))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x
  (If
   (Let 'x (Bool #t) (If (Var 'x) (Var 'x) (Prim 'not (list (Var 'x)))))
   (Bool #t)
   (Bool #f))
  (If (Var 'x) (Int 10) (Prim '- (list (Int 10))))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20834
  (If
   (Let
    'x20833
    (Bool #t)
    (If (Var 'x20833) (Var 'x20833) (Prim 'not (list (Var 'x20833)))))
   (Bool #t)
   (Bool #f))
  (If (Var 'x20834) (Int 10) (Prim '- (list (Int 10))))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20834
  (If
   (Let
    'x20833
    (Bool #t)
    (If (Var 'x20833) (Var 'x20833) (Prim 'not (list (Var 'x20833)))))
   (Bool #t)
   (Bool #f))
  (If (Var 'x20834) (Int 10) (Prim '- (list (Int 10))))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons
   'start
   (Seq
    (Assign (Var 'x20833) (Bool #t))
    (IfStmt
     (Prim 'eq? (list (Var 'x20833) (Bool #t)))
     (Goto 'block20840)
     (Goto 'block20841))))
  (cons
   'block20841
   (IfStmt
    (Prim 'eq? (list (Var 'x20833) (Bool #f)))
    (Goto 'block20838)
    (Goto 'block20839)))
  (cons
   'block20840
   (IfStmt
    (Prim 'eq? (list (Var 'x20833) (Bool #t)))
    (Goto 'block20838)
    (Goto 'block20839)))
  (cons 'block20839 (Seq (Assign (Var 'x20834) (Bool #f)) (Goto 'block20837)))
  (cons 'block20838 (Seq (Assign (Var 'x20834) (Bool #t)) (Goto 'block20837)))
  (cons
   'block20837
   (IfStmt
    (Prim 'eq? (list (Var 'x20834) (Bool #t)))
    (Goto 'block20835)
    (Goto 'block20836)))
  (cons 'block20836 (Return (Prim '- (list (Int 10)))))
  (cons 'block20835 (Return (Int 10)))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20833 . Boolean) (x20834 . Boolean)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 1) (Var 'x20833)))
     (Instr 'cmpq (list (Imm 1) (Var 'x20833)))
     (JmpIf 'e 'block20840)
     (Jmp 'block20841))))
  (cons
   'block20841
   (Block
    '()
    (list
     (Instr 'cmpq (list (Imm 0) (Var 'x20833)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20840
   (Block
    '()
    (list
     (Instr 'cmpq (list (Imm 1) (Var 'x20833)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20839
   (Block
    '()
    (list (Instr 'movq (list (Imm 0) (Var 'x20834))) (Jmp 'block20837))))
  (cons
   'block20838
   (Block
    '()
    (list (Instr 'movq (list (Imm 1) (Var 'x20834))) (Jmp 'block20837))))
  (cons
   'block20837
   (Block
    '()
    (list
     (Instr 'cmpq (list (Imm 1) (Var 'x20834)))
     (JmpIf 'e 'block20835)
     (Jmp 'block20836))))
  (cons
   'block20836
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20835
   (Block
    '()
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set:>)
(#<set:>)
(#<set: #<Var: x20834>>)
(#<set: #<Var: x20834>>)
(#<set:>)
(#<set:>)
(#<set: #<Var: x20833>>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20833 . Boolean) (x20834 . Boolean)))
 (list
  (cons
   'block20835
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'block20836
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20837
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Var 'x20834)))
     (JmpIf 'e 'block20835)
     (Jmp 'block20836))))
  (cons
   'block20838
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 1) (Var 'x20834))) (Jmp 'block20837))))
  (cons
   'block20839
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 0) (Var 'x20834))) (Jmp 'block20837))))
  (cons
   'block20840
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Var 'x20833)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20841
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 0) (Var 'x20833)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))))
    (list
     (Instr 'movq (list (Imm 1) (Var 'x20833)))
     (Instr 'cmpq (list (Imm 1) (Var 'x20833)))
     (JmpIf 'e 'block20840)
     (Jmp 'block20841))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20833 . Boolean) (x20834 . Boolean))
   (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20835
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'block20836
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20837
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Var 'x20834)))
     (JmpIf 'e 'block20835)
     (Jmp 'block20836))))
  (cons
   'block20838
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 1) (Var 'x20834))) (Jmp 'block20837))))
  (cons
   'block20839
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 0) (Var 'x20834))) (Jmp 'block20837))))
  (cons
   'block20840
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Var 'x20833)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20841
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 0) (Var 'x20833)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))))
    (list
     (Instr 'movq (list (Imm 1) (Var 'x20833)))
     (Instr 'cmpq (list (Imm 1) (Var 'x20833)))
     (JmpIf 'e 'block20840)
     (Jmp 'block20841))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20834>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20833> . #<set:>) (#<Var: x20834> . #<set:>))
old and updated-move-bias: 
((#<Var: x20833> . 0) (#<Var: x20834> . 0))
((#<Var: x20833> . 0) (#<Var: x20834> . 0))
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20833>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20833> . #<set:>) (#<Var: x20834> . #<set:>))
old and updated-move-bias: 
((#<Var: x20833> . 0) (#<Var: x20834> . 0))
((#<Var: x20833> . 0) (#<Var: x20834> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: x20834> . 0) (#<Var: x20833> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20833 . Boolean) (x20834 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20835
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'block20836
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20837
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20835)
     (Jmp 'block20836))))
  (cons
   'block20838
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 1) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20839
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 0) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20840
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20841
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20840)
     (Jmp 'block20841))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20841 -> start;
block20840 -> start;
block20839 -> block20841;
block20839 -> block20840;
block20838 -> block20841;
block20838 -> block20840;
block20837 -> block20839;
block20837 -> block20838;
block20836 -> block20837;
block20835 -> block20837;
(block20835 block20836 block20837 block20838 block20839 block20840 block20841 start)
removing label:
block20836
(#<Jmp: block20836> #<JmpIf: e block20835> #<Instr: cmpq (#<Imm: 1> #<Reg: rcx>)>)
(#<Instr: cmpq (#<Imm: 1> #<Reg: rcx>)> #<JmpIf: e block20835>)
(#<Instr: cmpq (#<Imm: 1> #<Reg: rcx>)> #<JmpIf: e block20835> #<Instr: movq (#<Imm: 10> #<Reg: rax>)> #<Instr: negq (#<Reg: rax>)> #<Jmp: conclusion>)
removing label:
block20841
(#<Jmp: block20841> #<JmpIf: e block20840> #<Instr: cmpq (#<Imm: 1> #<Reg: rcx>)> #<Instr: movq (#<Imm: 1> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 1> #<Reg: rcx>)> #<Instr: cmpq (#<Imm: 1> #<Reg: rcx>)> #<JmpIf: e block20840>)
(#<Instr: movq (#<Imm: 1> #<Reg: rcx>)> #<Instr: cmpq (#<Imm: 1> #<Reg: rcx>)> #<JmpIf: e block20840> #<Instr: cmpq (#<Imm: 0> #<Reg: rcx>)> #<JmpIf: e block20838> #<Jmp: block20839>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20833 . Boolean) (x20834 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20835
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'block20836
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20837
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20835)
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20838
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 1) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20839
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 0) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20840
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20841
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20840)
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20833 . Boolean) (x20834 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20835
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'block20836
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20837
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20835)
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20838
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 1) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20839
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 0) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20840
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20841
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20840)
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20833 . Boolean) (x20834 . Boolean))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20835
   (Block
    (list (list 'live-sets (set) (set)))
    (list (Instr 'movq (list (Imm 10) (Reg 'rax))) (Jmp 'conclusion))))
  (cons
   'block20836
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20837
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20835)
     (Instr 'movq (list (Imm 10) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20838
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 1) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20839
   (Block
    (list (list 'live-sets (set (Var 'x20834)) (set (Var 'x20834))))
    (list (Instr 'movq (list (Imm 0) (Reg 'rcx))) (Jmp 'block20837))))
  (cons
   'block20840
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'block20841
   (Block
    (list (list 'live-sets (set) (set) (set)))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))
      (set (Var 'x20833))))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rcx)))
     (JmpIf 'e 'block20840)
     (Instr 'cmpq (list (Imm 0) (Reg 'rcx)))
     (JmpIf 'e 'block20838)
     (Jmp 'block20839))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20835:
	movq	$10, %rax
	jmp _conclusion

	.align 16
_block20836:
	movq	$10, %rax
	negq	%rax
	jmp _conclusion

	.align 16
_block20837:
	cmpq	$1, %rcx
	je _block20835
	movq	$10, %rax
	negq	%rax
	jmp _conclusion

	.align 16
_block20838:
	movq	$1, %rcx
	jmp _block20837

	.align 16
_block20839:
	movq	$0, %rcx
	jmp _block20837

	.align 16
_block20840:
	cmpq	$1, %rcx
	je _block20838
	jmp _block20839

	.align 16
_block20841:
	cmpq	$0, %rcx
	je _block20838
	jmp _block20839

	.align 16
_start:
	movq	$1, %rcx
	cmpq	$1, %rcx
	je _block20840
	cmpq	$0, %rcx
	je _block20838
	jmp _block20839

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_91.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (If
  (Prim 'and (list (Bool #t) (Prim 'or (list (Bool #f) (Bool #t)))))
  (Prim '+ (list (Int 1) (Int 2)))
  (Prim '- (list (Int 10) (Int 5)))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (If
  (If (Bool #t) (If (Bool #f) (Bool #t) (Bool #t)) (Bool #f))
  (Prim '+ (list (Int 1) (Int 2)))
  (Prim '+ (list (Int 10) (Prim '- (list (Int 5)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (If
  (If (Bool #t) (If (Bool #f) (Bool #t) (Bool #t)) (Bool #f))
  (Prim '+ (list (Int 1) (Int 2)))
  (Prim '+ (list (Int 10) (Prim '- (list (Int 5)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (If
  (If (Bool #t) (If (Bool #f) (Bool #t) (Bool #t)) (Bool #f))
  (Prim '+ (list (Int 1) (Int 2)))
  (Let
   'tmp20842
   (Prim '- (list (Int 5)))
   (Prim '+ (list (Int 10) (Var 'tmp20842))))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons 'start (Goto 'block20843))
  (cons 'block20843 (Return (Prim '+ (list (Int 1) (Int 2)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons 'start (Block '() (list (Jmp 'block20843))))
  (cons
   'block20843
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'block20843
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20843))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20843
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20843))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20843
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20843))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20843 -> start;
(block20843 start)
removing label:
block20843
(#<Jmp: block20843>)
()
(#<Instr: movq (#<Imm: 1> #<Reg: rax>)> #<Instr: addq (#<Imm: 2> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20843
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20843
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20843
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 1) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20843:
	movq	$1, %rax
	addq	$2, %rax
	jmp _conclusion

	.align 16
_start:
	movq	$1, %rax
	addq	$2, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_92.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (Prim '+ (list (Int 2) (Int 1))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (Int 2) (Int 1))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (Int 2) (Int 1))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (Int 2) (Int 1))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram '() (list (cons 'start (Return (Prim '+ (list (Int 2) (Int 1)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

(start)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types)
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Imm 1) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_start:
	movq	$2, %rax
	addq	$1, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_93.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (Prim '+ (list (Int 2) (If (Bool #t) (Int 10) (Int 5)))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (Int 2) (If (Bool #t) (Int 10) (Int 5)))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (Int 2) (If (Bool #t) (Int 10) (Int 5)))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'tmp20844
  (If (Bool #t) (Int 10) (Int 5))
  (Prim '+ (list (Int 2) (Var 'tmp20844)))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons 'start (Seq (Assign (Var 'tmp20844) (Int 10)) (Goto 'block20845)))
  (cons 'block20845 (Return (Prim '+ (list (Int 2) (Var 'tmp20844)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20844 . Integer)))
 (list
  (cons
   'start
   (Block
    '()
    (list (Instr 'movq (list (Imm 10) (Var 'tmp20844))) (Jmp 'block20845))))
  (cons
   'block20845
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Var 'tmp20844) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set: #<Var: tmp20844>>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20844 . Integer)))
 (list
  (cons
   'block20845
   (Block
    (list (list 'live-sets (set (Reg 'rax) (Var 'tmp20844)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Var 'tmp20844) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20844)) (set (Var 'tmp20844))))
    (list (Instr 'movq (list (Imm 10) (Var 'tmp20844))) (Jmp 'block20845))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

#<Var: tmp20844> -> #<Reg: rax>;
#<Reg: rax> -> #<Var: tmp20844>;
build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20844 . Integer)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20845
   (Block
    (list (list 'live-sets (set (Reg 'rax) (Var 'tmp20844)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Var 'tmp20844) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20844)) (set (Var 'tmp20844))))
    (list (Instr 'movq (list (Imm 10) (Var 'tmp20844))) (Jmp 'block20845))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: tmp20844>
(#<Reg: rax>)
#<set:>
#<set: -1>
0
updated-saturation: ((#<Var: tmp20844> . #<set: -1>))
old and updated-move-bias: 
((#<Var: tmp20844> . 0))
((#<Var: tmp20844> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: tmp20844> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20844 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20845
   (Block
    (list (list 'live-sets (set (Reg 'rax) (Var 'tmp20844)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20844)) (set (Var 'tmp20844))))
    (list (Instr 'movq (list (Imm 10) (Reg 'rcx))) (Jmp 'block20845))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20845 -> start;
(block20845 start)
removing label:
block20845
(#<Jmp: block20845> #<Instr: movq (#<Imm: 10> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 10> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 10> #<Reg: rcx>)> #<Instr: movq (#<Imm: 2> #<Reg: rax>)> #<Instr: addq (#<Reg: rcx> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20844 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20845
   (Block
    (list (list 'live-sets (set (Reg 'rax) (Var 'tmp20844)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20844)) (set (Var 'tmp20844))))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20844 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20845
   (Block
    (list (list 'live-sets (set (Reg 'rax) (Var 'tmp20844)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20844)) (set (Var 'tmp20844))))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20844 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20845
   (Block
    (list (list 'live-sets (set (Reg 'rax) (Var 'tmp20844)) (set) (set)))
    (list
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20844)) (set (Var 'tmp20844))))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 2) (Reg 'rax)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20845:
	movq	$2, %rax
	addq	%rcx, %rax
	jmp _conclusion

	.align 16
_start:
	movq	$10, %rcx
	movq	$2, %rax
	addq	%rcx, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_94.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Let
  'x
  (If
   (Prim 'and (list (Bool #t) (Prim 'or (list (Bool #f) (Bool #t)))))
   (Prim '- (list (Int 9) (Int 6)))
   (Prim '+ (list (Int 4) (Int 2))))
  (Let
   'x
   (Prim '+ (list (Var 'x) (Var 'x)))
   (Prim '+ (list (Var 'x) (Int 10))))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x
  (If
   (If (Bool #t) (If (Bool #f) (Bool #t) (Bool #t)) (Bool #f))
   (Prim '+ (list (Int 9) (Prim '- (list (Int 6)))))
   (Prim '+ (list (Int 4) (Int 2))))
  (Let
   'x
   (Prim '+ (list (Var 'x) (Var 'x)))
   (Prim '+ (list (Var 'x) (Int 10))))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20846
  (If
   (If (Bool #t) (If (Bool #f) (Bool #t) (Bool #t)) (Bool #f))
   (Prim '+ (list (Int 9) (Prim '- (list (Int 6)))))
   (Prim '+ (list (Int 4) (Int 2))))
  (Let
   'x20847
   (Prim '+ (list (Var 'x20846) (Var 'x20846)))
   (Prim '+ (list (Var 'x20847) (Int 10))))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20846
  (If
   (If (Bool #t) (If (Bool #f) (Bool #t) (Bool #t)) (Bool #f))
   (Let
    'tmp20848
    (Prim '- (list (Int 6)))
    (Prim '+ (list (Int 9) (Var 'tmp20848))))
   (Prim '+ (list (Int 4) (Int 2))))
  (Let
   'x20847
   (Prim '+ (list (Var 'x20846) (Var 'x20846)))
   (Prim '+ (list (Var 'x20847) (Int 10))))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons 'start (Goto 'block20850))
  (cons
   'block20850
   (Seq
    (Assign (Var 'tmp20848) (Prim '- (list (Int 6))))
    (Seq
     (Assign (Var 'x20846) (Prim '+ (list (Int 9) (Var 'tmp20848))))
     (Goto 'block20849))))
  (cons
   'block20849
   (Seq
    (Assign (Var 'x20847) (Prim '+ (list (Var 'x20846) (Var 'x20846))))
    (Return (Prim '+ (list (Var 'x20847) (Int 10))))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer)))
 (list
  (cons 'start (Block '() (list (Jmp 'block20850))))
  (cons
   'block20850
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 6) (Var 'tmp20848)))
     (Instr 'negq (list (Var 'tmp20848)))
     (Instr 'movq (list (Imm 9) (Var 'x20846)))
     (Instr 'addq (list (Var 'tmp20848) (Var 'x20846)))
     (Jmp 'block20849))))
  (cons
   'block20849
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'x20846) (Var 'x20847)))
     (Instr 'addq (list (Var 'x20846) (Var 'x20847)))
     (Instr 'movq (list (Var 'x20847) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set: #<Var: x20846>>)
(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer)))
 (list
  (cons
   'block20849
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20846) (Var 'x20847))
      (set (Var 'x20847))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Var 'x20846) (Var 'x20847)))
     (Instr 'addq (list (Var 'x20846) (Var 'x20847)))
     (Instr 'movq (list (Var 'x20847) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20850
   (Block
    (list
     (list
      'live-sets
      (set (Var 'tmp20848))
      (set (Var 'tmp20848))
      (set (Var 'x20846) (Var 'tmp20848))
      (set (Var 'x20846))
      (set (Var 'x20846))))
    (list
     (Instr 'movq (list (Imm 6) (Var 'tmp20848)))
     (Instr 'negq (list (Var 'tmp20848)))
     (Instr 'movq (list (Imm 9) (Var 'x20846)))
     (Instr 'addq (list (Var 'tmp20848) (Var 'x20846)))
     (Jmp 'block20849))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20850))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

#<Var: tmp20848> -> #<Var: x20846>;
#<Var: x20846> -> #<Var: tmp20848>;
build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer))
   (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20849
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20846) (Var 'x20847))
      (set (Var 'x20847))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Var 'x20846) (Var 'x20847)))
     (Instr 'addq (list (Var 'x20846) (Var 'x20847)))
     (Instr 'movq (list (Var 'x20847) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20850
   (Block
    (list
     (list
      'live-sets
      (set (Var 'tmp20848))
      (set (Var 'tmp20848))
      (set (Var 'x20846) (Var 'tmp20848))
      (set (Var 'x20846))
      (set (Var 'x20846))))
    (list
     (Instr 'movq (list (Imm 6) (Var 'tmp20848)))
     (Instr 'negq (list (Var 'tmp20848)))
     (Instr 'movq (list (Imm 9) (Var 'x20846)))
     (Instr 'addq (list (Var 'tmp20848) (Var 'x20846)))
     (Jmp 'block20849))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20850))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: #<Var: x20847> -> #<Var: x20846>;
#<Var: x20846> -> #<Var: x20847>;
move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20846>
(#<Var: tmp20848>)
#<set:>
#<set:>
0
updated-saturation: ((#<Var: tmp20848> . #<set: 0>) (#<Var: x20847> . #<set:>) (#<Var: x20846> . #<set:>))
old and updated-move-bias: 
((#<Var: tmp20848> . 0) (#<Var: x20847> . 0) (#<Var: x20846> . 0))
((#<Var: tmp20848> . 0) (#<Var: x20847> . 1) (#<Var: x20846> . 0))
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: tmp20848>
(#<Var: x20846>)
#<set:>
#<set: 0>
1
updated-saturation: ((#<Var: tmp20848> . #<set: 0>) (#<Var: x20847> . #<set:>) (#<Var: x20846> . #<set: 1>))
old and updated-move-bias: 
((#<Var: tmp20848> . 0) (#<Var: x20847> . 1) (#<Var: x20846> . 0))
((#<Var: tmp20848> . 0) (#<Var: x20847> . 1) (#<Var: x20846> . 0))
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20847>
()
#<set: 0>
#<set:>
0
updated-saturation: ((#<Var: tmp20848> . #<set: 0>) (#<Var: x20847> . #<set:>) (#<Var: x20846> . #<set: 1>))
old and updated-move-bias: 
((#<Var: tmp20848> . 0) (#<Var: x20847> . 1) (#<Var: x20846> . 0))
((#<Var: tmp20848> . 0) (#<Var: x20847> . 1) (#<Var: x20846> . 1))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: x20846> . 0) (#<Var: tmp20848> . 1) (#<Var: x20847> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20849
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20846) (Var 'x20847))
      (set (Var 'x20847))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20850
   (Block
    (list
     (list
      'live-sets
      (set (Var 'tmp20848))
      (set (Var 'tmp20848))
      (set (Var 'x20846) (Var 'tmp20848))
      (set (Var 'x20846))
      (set (Var 'x20846))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Jmp 'block20849))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20850))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20849 -> block20850;
block20850 -> start;
(block20849 block20850 start)
removing label:
block20849
(#<Jmp: block20849> #<Instr: addq (#<Reg: rdx> #<Reg: rcx>)> #<Instr: movq (#<Imm: 9> #<Reg: rcx>)> #<Instr: negq (#<Reg: rdx>)> #<Instr: movq (#<Imm: 6> #<Reg: rdx>)>)
(#<Instr: movq (#<Imm: 6> #<Reg: rdx>)> #<Instr: negq (#<Reg: rdx>)> #<Instr: movq (#<Imm: 9> #<Reg: rcx>)> #<Instr: addq (#<Reg: rdx> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 6> #<Reg: rdx>)> #<Instr: negq (#<Reg: rdx>)> #<Instr: movq (#<Imm: 9> #<Reg: rcx>)> #<Instr: addq (#<Reg: rdx> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rcx>)> #<Instr: addq (#<Reg: rcx> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 10> #<Reg: rax>)> #<Jmp: conclusion>)
removing label:
block20850
(#<Jmp: block20850>)
()
(#<Instr: movq (#<Imm: 6> #<Reg: rdx>)> #<Instr: negq (#<Reg: rdx>)> #<Instr: movq (#<Imm: 9> #<Reg: rcx>)> #<Instr: addq (#<Reg: rdx> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rcx>)> #<Instr: addq (#<Reg: rcx> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 10> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20849
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20846) (Var 'x20847))
      (set (Var 'x20847))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20850
   (Block
    (list
     (list
      'live-sets
      (set (Var 'tmp20848))
      (set (Var 'tmp20848))
      (set (Var 'x20846) (Var 'tmp20848))
      (set (Var 'x20846))
      (set (Var 'x20846))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20849
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20846) (Var 'x20847))
      (set (Var 'x20847))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20850
   (Block
    (list
     (list
      'live-sets
      (set (Var 'tmp20848))
      (set (Var 'tmp20848))
      (set (Var 'x20846) (Var 'tmp20848))
      (set (Var 'x20846))
      (set (Var 'x20846))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20848 . Integer) (x20847 . Integer) (x20846 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20849
   (Block
    (list
     (list
      'live-sets
      (set (Var 'x20846) (Var 'x20847))
      (set (Var 'x20847))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20850
   (Block
    (list
     (list
      'live-sets
      (set (Var 'tmp20848))
      (set (Var 'tmp20848))
      (set (Var 'x20846) (Var 'tmp20848))
      (set (Var 'x20846))
      (set (Var 'x20846))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rdx)))
     (Instr 'negq (list (Reg 'rdx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rdx) (Reg 'rcx)))
     (Instr 'addq (list (Reg 'rcx) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20849:
	addq	%rcx, %rcx
	movq	%rcx, %rax
	addq	$10, %rax
	jmp _conclusion

	.align 16
_block20850:
	movq	$6, %rdx
	negq	%rdx
	movq	$9, %rcx
	addq	%rdx, %rcx
	addq	%rcx, %rcx
	movq	%rcx, %rax
	addq	$10, %rax
	jmp _conclusion

	.align 16
_start:
	movq	$6, %rdx
	negq	%rdx
	movq	$9, %rcx
	addq	%rdx, %rcx
	addq	%rcx, %rcx
	movq	%rcx, %rax
	addq	$10, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_95.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Let
  'x
  (Int 10)
  (Let 'x (Int 5) (Let 'x (Prim '- (list (Int 9))) (Prim '- (list (Var 'x)))))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x
  (Int 10)
  (Let 'x (Int 5) (Let 'x (Prim '- (list (Int 9))) (Prim '- (list (Var 'x)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20851
  (Int 10)
  (Let
   'x20852
   (Int 5)
   (Let 'x20853 (Prim '- (list (Int 9))) (Prim '- (list (Var 'x20853)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20851
  (Int 10)
  (Let
   'x20852
   (Int 5)
   (Let 'x20853 (Prim '- (list (Int 9))) (Prim '- (list (Var 'x20853)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons
   'start
   (Seq
    (Assign (Var 'x20851) (Int 10))
    (Seq
     (Assign (Var 'x20852) (Int 5))
     (Seq
      (Assign (Var 'x20853) (Prim '- (list (Int 9))))
      (Return (Prim '- (list (Var 'x20853))))))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Instr 'movq (list (Imm 10) (Var 'x20851)))
     (Instr 'movq (list (Imm 5) (Var 'x20852)))
     (Instr 'movq (list (Imm 9) (Var 'x20853)))
     (Instr 'negq (list (Var 'x20853)))
     (Instr 'movq (list (Var 'x20853) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer)))
 (list
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set)
      (set)
      (set (Var 'x20853))
      (set (Var 'x20853))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Imm 10) (Var 'x20851)))
     (Instr 'movq (list (Imm 5) (Var 'x20852)))
     (Instr 'movq (list (Imm 9) (Var 'x20853)))
     (Instr 'negq (list (Var 'x20853)))
     (Instr 'movq (list (Var 'x20853) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer))
   (conflicts . #<unweighted-graph>))
 (list
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set)
      (set)
      (set (Var 'x20853))
      (set (Var 'x20853))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Imm 10) (Var 'x20851)))
     (Instr 'movq (list (Imm 5) (Var 'x20852)))
     (Instr 'movq (list (Imm 9) (Var 'x20853)))
     (Instr 'negq (list (Var 'x20853)))
     (Instr 'movq (list (Var 'x20853) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20851>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20853> . #<set:>) (#<Var: x20852> . #<set:>) (#<Var: x20851> . #<set:>))
old and updated-move-bias: 
((#<Var: x20853> . 0) (#<Var: x20852> . 0) (#<Var: x20851> . 0))
((#<Var: x20853> . 0) (#<Var: x20852> . 0) (#<Var: x20851> . 0))
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20853>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20853> . #<set:>) (#<Var: x20852> . #<set:>) (#<Var: x20851> . #<set:>))
old and updated-move-bias: 
((#<Var: x20853> . 0) (#<Var: x20852> . 0) (#<Var: x20851> . 0))
((#<Var: x20853> . 0) (#<Var: x20852> . 0) (#<Var: x20851> . 0))
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20852>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: x20853> . #<set:>) (#<Var: x20852> . #<set:>) (#<Var: x20851> . #<set:>))
old and updated-move-bias: 
((#<Var: x20853> . 0) (#<Var: x20852> . 0) (#<Var: x20851> . 0))
((#<Var: x20853> . 0) (#<Var: x20852> . 0) (#<Var: x20851> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: x20851> . 0) (#<Var: x20853> . 0) (#<Var: x20852> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set)
      (set)
      (set (Var 'x20853))
      (set (Var 'x20853))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 5) (Reg 'rcx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'negq (list (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

(start)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set)
      (set)
      (set (Var 'x20853))
      (set (Var 'x20853))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 5) (Reg 'rcx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'negq (list (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set)
      (set)
      (set (Var 'x20853))
      (set (Var 'x20853))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 5) (Reg 'rcx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'negq (list (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (x20853 . Integer) (x20852 . Integer) (x20851 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set)
      (set)
      (set (Var 'x20853))
      (set (Var 'x20853))
      (set (Reg 'rax))
      (set)
      (set)))
    (list
     (Instr 'movq (list (Imm 10) (Reg 'rcx)))
     (Instr 'movq (list (Imm 5) (Reg 'rcx)))
     (Instr 'movq (list (Imm 9) (Reg 'rcx)))
     (Instr 'negq (list (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'negq (list (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_start:
	movq	$10, %rcx
	movq	$5, %rcx
	movq	$9, %rcx
	negq	%rcx
	movq	%rcx, %rax
	negq	%rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_96.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program '() (Prim '+ (list (If (Bool #t) (Int 6) (Int 9)) (Int 4))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (If (Bool #t) (Int 6) (Int 9)) (Int 4))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program '() (Prim '+ (list (If (Bool #t) (Int 6) (Int 9)) (Int 4))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'tmp20854
  (If (Bool #t) (Int 6) (Int 9))
  (Prim '+ (list (Var 'tmp20854) (Int 4)))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons 'start (Seq (Assign (Var 'tmp20854) (Int 6)) (Goto 'block20855)))
  (cons 'block20855 (Return (Prim '+ (list (Var 'tmp20854) (Int 4)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20854 . Integer)))
 (list
  (cons
   'start
   (Block
    '()
    (list (Instr 'movq (list (Imm 6) (Var 'tmp20854))) (Jmp 'block20855))))
  (cons
   'block20855
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'tmp20854) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set: #<Var: tmp20854>>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20854 . Integer)))
 (list
  (cons
   'block20855
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'tmp20854) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20854)) (set (Var 'tmp20854))))
    (list (Instr 'movq (list (Imm 6) (Var 'tmp20854))) (Jmp 'block20855))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20854 . Integer)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20855
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'tmp20854) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20854)) (set (Var 'tmp20854))))
    (list (Instr 'movq (list (Imm 6) (Var 'tmp20854))) (Jmp 'block20855))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: tmp20854>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: tmp20854> . #<set:>))
old and updated-move-bias: 
((#<Var: tmp20854> . 0))
((#<Var: tmp20854> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: tmp20854> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20854 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20855
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20854)) (set (Var 'tmp20854))))
    (list (Instr 'movq (list (Imm 6) (Reg 'rcx))) (Jmp 'block20855))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20855 -> start;
(block20855 start)
removing label:
block20855
(#<Jmp: block20855> #<Instr: movq (#<Imm: 6> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 6> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 6> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 4> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20854 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20855
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20854)) (set (Var 'tmp20854))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20854 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20855
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20854)) (set (Var 'tmp20854))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20854 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20855
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set (Var 'tmp20854)) (set (Var 'tmp20854))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20855:
	movq	%rcx, %rax
	addq	$4, %rax
	jmp _conclusion

	.align 16
_start:
	movq	$6, %rcx
	movq	%rcx, %rax
	addq	$4, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_97.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Prim
  '+
  (list
   (If
    (Prim 'or (list (Bool #f) (Prim 'and (list (Bool #t) (Bool #t)))))
    (Int 6)
    (Int 9))
   (Int 4))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Prim
  '+
  (list
   (If
    (If (Bool #f) (Bool #t) (If (Bool #t) (Bool #t) (Bool #f)))
    (Int 6)
    (Int 9))
   (Int 4))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Prim
  '+
  (list
   (If
    (If (Bool #f) (Bool #t) (If (Bool #t) (Bool #t) (Bool #f)))
    (Int 6)
    (Int 9))
   (Int 4))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'tmp20856
  (If
   (If (Bool #f) (Bool #t) (If (Bool #t) (Bool #t) (Bool #f)))
   (Int 6)
   (Int 9))
  (Prim '+ (list (Var 'tmp20856) (Int 4)))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons 'start (Goto 'block20858))
  (cons 'block20858 (Seq (Assign (Var 'tmp20856) (Int 6)) (Goto 'block20857)))
  (cons 'block20857 (Return (Prim '+ (list (Var 'tmp20856) (Int 4)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20856 . Integer)))
 (list
  (cons 'start (Block '() (list (Jmp 'block20858))))
  (cons
   'block20858
   (Block
    '()
    (list (Instr 'movq (list (Imm 6) (Var 'tmp20856))) (Jmp 'block20857))))
  (cons
   'block20857
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'tmp20856) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set: #<Var: tmp20856>>)
(#<set:>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20856 . Integer)))
 (list
  (cons
   'block20857
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'tmp20856) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20858
   (Block
    (list (list 'live-sets (set (Var 'tmp20856)) (set (Var 'tmp20856))))
    (list (Instr 'movq (list (Imm 6) (Var 'tmp20856))) (Jmp 'block20857))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20858))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (tmp20856 . Integer)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20857
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'tmp20856) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20858
   (Block
    (list (list 'live-sets (set (Var 'tmp20856)) (set (Var 'tmp20856))))
    (list (Instr 'movq (list (Imm 6) (Var 'tmp20856))) (Jmp 'block20857))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20858))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: tmp20856>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: tmp20856> . #<set:>))
old and updated-move-bias: 
((#<Var: tmp20856> . 0))
((#<Var: tmp20856> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: tmp20856> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20856 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20857
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20858
   (Block
    (list (list 'live-sets (set (Var 'tmp20856)) (set (Var 'tmp20856))))
    (list (Instr 'movq (list (Imm 6) (Reg 'rcx))) (Jmp 'block20857))))
  (cons
   'start
   (Block (list (list 'live-sets (set))) (list (Jmp 'block20858))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20857 -> block20858;
block20858 -> start;
(block20857 block20858 start)
removing label:
block20857
(#<Jmp: block20857> #<Instr: movq (#<Imm: 6> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 6> #<Reg: rcx>)>)
(#<Instr: movq (#<Imm: 6> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 4> #<Reg: rax>)> #<Jmp: conclusion>)
removing label:
block20858
(#<Jmp: block20858>)
()
(#<Instr: movq (#<Imm: 6> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 4> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20856 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20857
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20858
   (Block
    (list (list 'live-sets (set (Var 'tmp20856)) (set (Var 'tmp20856))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20856 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20857
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20858
   (Block
    (list (list 'live-sets (set (Var 'tmp20856)) (set (Var 'tmp20856))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (tmp20856 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20857
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20858
   (Block
    (list (list 'live-sets (set (Var 'tmp20856)) (set (Var 'tmp20856))))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list (list 'live-sets (set)))
    (list
     (Instr 'movq (list (Imm 6) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 4) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20857:
	movq	%rcx, %rax
	addq	$4, %rax
	jmp _conclusion

	.align 16
_block20858:
	movq	$6, %rcx
	movq	%rcx, %rax
	addq	$4, %rax
	jmp _conclusion

	.align 16
_start:
	movq	$6, %rcx
	movq	%rcx, %rax
	addq	$4, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_98.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Let
  'x
  (Prim 'read '())
  (Let
   'y
   (Prim 'read '())
   (If
    (If
     (Prim '< (list (Var 'x) (Int 1)))
     (Prim 'eq? (list (Var 'x) (Int 0)))
     (Prim 'eq? (list (Var 'x) (Int 2))))
    (Prim '+ (list (Var 'y) (Int 2)))
    (Prim '+ (list (Var 'y) (Int 10)))))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x
  (Prim 'read '())
  (Let
   'y
   (Prim 'read '())
   (If
    (If
     (Prim '< (list (Var 'x) (Int 1)))
     (Prim 'eq? (list (Var 'x) (Int 0)))
     (Prim 'eq? (list (Var 'x) (Int 2))))
    (Prim '+ (list (Var 'y) (Int 2)))
    (Prim '+ (list (Var 'y) (Int 10)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20859
  (Prim 'read '())
  (Let
   'y20860
   (Prim 'read '())
   (If
    (If
     (Prim '< (list (Var 'x20859) (Int 1)))
     (Prim 'eq? (list (Var 'x20859) (Int 0)))
     (Prim 'eq? (list (Var 'x20859) (Int 2))))
    (Prim '+ (list (Var 'y20860) (Int 2)))
    (Prim '+ (list (Var 'y20860) (Int 10)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'x20859
  (Prim 'read '())
  (Let
   'y20860
   (Prim 'read '())
   (If
    (If
     (Prim '< (list (Var 'x20859) (Int 1)))
     (Prim 'eq? (list (Var 'x20859) (Int 0)))
     (Prim 'eq? (list (Var 'x20859) (Int 2))))
    (Prim '+ (list (Var 'y20860) (Int 2)))
    (Prim '+ (list (Var 'y20860) (Int 10)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons
   'start
   (Seq
    (Assign (Var 'x20859) (Prim 'read '()))
    (Seq
     (Assign (Var 'y20860) (Prim 'read '()))
     (IfStmt
      (Prim '< (list (Var 'x20859) (Int 1)))
      (Goto 'block20863)
      (Goto 'block20864)))))
  (cons
   'block20864
   (IfStmt
    (Prim 'eq? (list (Var 'x20859) (Int 2)))
    (Goto 'block20861)
    (Goto 'block20862)))
  (cons
   'block20863
   (IfStmt
    (Prim 'eq? (list (Var 'x20859) (Int 0)))
    (Goto 'block20861)
    (Goto 'block20862)))
  (cons 'block20862 (Return (Prim '+ (list (Var 'y20860) (Int 10)))))
  (cons 'block20861 (Return (Prim '+ (list (Var 'y20860) (Int 2)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20860 . Integer) (x20859 . Integer)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'x20859)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20860)))
     (Instr 'cmpq (list (Imm 1) (Var 'x20859)))
     (JmpIf 'l 'block20863)
     (Jmp 'block20864))))
  (cons
   'block20864
   (Block
    '()
    (list
     (Instr 'cmpq (list (Imm 2) (Var 'x20859)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20863
   (Block
    '()
    (list
     (Instr 'cmpq (list (Imm 0) (Var 'x20859)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20862
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'y20860) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20861
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'y20860) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set:>)
(#<set: #<Var: y20860>>)
(#<set: #<Var: y20860>>)
(#<set: #<Var: x20859> #<Var: y20860>>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20860 . Integer) (x20859 . Integer)))
 (list
  (cons
   'block20861
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20860) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20862
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20860) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20863
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 0) (Var 'x20859)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20864
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 2) (Var 'x20859)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'x20859))
      (set (Reg 'rax) (Var 'x20859))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'x20859)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20860)))
     (Instr 'cmpq (list (Imm 1) (Var 'x20859)))
     (JmpIf 'l 'block20863)
     (Jmp 'block20864))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

#<Reg: r11> -> #<Reg: rax>;
#<Reg: r11> -> #<Var: x20859>;
#<Reg: rsi> -> #<Reg: rax>;
#<Reg: rsi> -> #<Var: x20859>;
#<Reg: r10> -> #<Reg: rax>;
#<Reg: r10> -> #<Var: x20859>;
#<Reg: r9> -> #<Reg: rax>;
#<Reg: r9> -> #<Var: x20859>;
#<Reg: rdi> -> #<Reg: rax>;
#<Reg: rdi> -> #<Var: x20859>;
#<Var: x20859> -> #<Reg: rax>;
#<Var: x20859> -> #<Reg: rdx>;
#<Var: x20859> -> #<Reg: rsi>;
#<Var: x20859> -> #<Reg: r8>;
#<Var: x20859> -> #<Reg: r9>;
#<Var: x20859> -> #<Reg: r11>;
#<Var: x20859> -> #<Reg: r10>;
#<Var: x20859> -> #<Var: y20860>;
#<Var: x20859> -> #<Reg: rdi>;
#<Var: x20859> -> #<Reg: rcx>;
#<Var: y20860> -> #<Var: x20859>;
#<Reg: rax> -> #<Var: x20859>;
#<Reg: rax> -> #<Reg: rdx>;
#<Reg: rax> -> #<Reg: rsi>;
#<Reg: rax> -> #<Reg: r8>;
#<Reg: rax> -> #<Reg: r9>;
#<Reg: rax> -> #<Reg: r11>;
#<Reg: rax> -> #<Reg: r10>;
#<Reg: rax> -> #<Reg: rdi>;
#<Reg: rax> -> #<Reg: rcx>;
#<Reg: r8> -> #<Reg: rax>;
#<Reg: r8> -> #<Var: x20859>;
#<Reg: rdx> -> #<Reg: rax>;
#<Reg: rdx> -> #<Var: x20859>;
#<Reg: rcx> -> #<Reg: rax>;
#<Reg: rcx> -> #<Var: x20859>;
build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20860 . Integer) (x20859 . Integer))
   (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20861
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20860) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20862
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20860) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20863
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 0) (Var 'x20859)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20864
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 2) (Var 'x20859)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'x20859))
      (set (Reg 'rax) (Var 'x20859))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'x20859)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20860)))
     (Instr 'cmpq (list (Imm 1) (Var 'x20859)))
     (JmpIf 'l 'block20863)
     (Jmp 'block20864))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: x20859>
(#<Reg: rax> #<Reg: rdx> #<Reg: rsi> #<Reg: r8> #<Reg: r9> #<Reg: r11> #<Reg: r10> #<Var: y20860> #<Reg: rdi> #<Reg: rcx>)
#<set:>
#<set: 0 1 2 3 4 5 6 7 -1>
8
updated-saturation: ((#<Var: y20860> . #<set: 8>) (#<Var: x20859> . #<set: 0 1 2 3 4 5 6 7 -1>))
old and updated-move-bias: 
((#<Var: y20860> . 0) (#<Var: x20859> . 0))
((#<Var: y20860> . 0) (#<Var: x20859> . 0))
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: y20860>
(#<Var: x20859>)
#<set:>
#<set: 8>
0
updated-saturation: ((#<Var: y20860> . #<set: 8>) (#<Var: x20859> . #<set: 0 1 2 3 4 5 6 7 -1>))
old and updated-move-bias: 
((#<Var: y20860> . 0) (#<Var: x20859> . 0))
((#<Var: y20860> . 0) (#<Var: x20859> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: x20859> . 8) (#<Var: y20860> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20860 . Integer) (x20859 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set (Reg 'rbx)))
  '(stack-space . 16))
 (list
  (cons
   'block20861
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20862
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20863
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20864
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'x20859))
      (set (Reg 'rax) (Var 'x20859))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rbx)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rbx)))
     (JmpIf 'l 'block20863)
     (Jmp 'block20864))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20864 -> start;
block20863 -> start;
block20862 -> block20864;
block20862 -> block20863;
block20861 -> block20864;
block20861 -> block20863;
(block20861 block20862 block20863 block20864 start)
removing label:
block20864
(#<Jmp: block20864> #<JmpIf: l block20863> #<Instr: cmpq (#<Imm: 1> #<Reg: rbx>)> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rbx>)> #<Callq: read_int 0>)
(#<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rbx>)> #<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Instr: cmpq (#<Imm: 1> #<Reg: rbx>)> #<JmpIf: l block20863>)
(#<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rbx>)> #<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Instr: cmpq (#<Imm: 1> #<Reg: rbx>)> #<JmpIf: l block20863> #<Instr: cmpq (#<Imm: 2> #<Reg: rbx>)> #<JmpIf: e block20861> #<Jmp: block20862>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20860 . Integer) (x20859 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set (Reg 'rbx)))
  '(stack-space . 16))
 (list
  (cons
   'block20861
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20862
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20863
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20864
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'x20859))
      (set (Reg 'rax) (Var 'x20859))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rbx)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rbx)))
     (JmpIf 'l 'block20863)
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20860 . Integer) (x20859 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set (Reg 'rbx)))
  '(stack-space . 16))
 (list
  (cons
   'block20861
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20862
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20863
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20864
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'x20859))
      (set (Reg 'rax) (Var 'x20859))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rbx)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rbx)))
     (JmpIf 'l 'block20863)
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20860 . Integer) (x20859 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set (Reg 'rbx)))
  '(stack-space . 16))
 (list
  (cons
   'block20861
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20862
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 10) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'block20863
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 0) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'block20864
   (Block
    (list
     (list
      'live-sets
      (set (Var 'y20860))
      (set (Var 'y20860))
      (set (Var 'y20860))))
    (list
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'x20859))
      (set (Reg 'rax) (Var 'x20859))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))
      (set (Var 'x20859) (Var 'y20860))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rbx)))
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'cmpq (list (Imm 1) (Reg 'rbx)))
     (JmpIf 'l 'block20863)
     (Instr 'cmpq (list (Imm 2) (Reg 'rbx)))
     (JmpIf 'e 'block20861)
     (Jmp 'block20862))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'pushq (list (Reg 'rbx)))
     (Instr 'subq (list (Imm 8) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 8) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbx)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20861:
	movq	%rcx, %rax
	addq	$2, %rax
	jmp _conclusion

	.align 16
_block20862:
	movq	%rcx, %rax
	addq	$10, %rax
	jmp _conclusion

	.align 16
_block20863:
	cmpq	$0, %rbx
	je _block20861
	jmp _block20862

	.align 16
_block20864:
	cmpq	$2, %rbx
	je _block20861
	jmp _block20862

	.align 16
_start:
	callq	_read_int
	movq	%rax, %rbx
	callq	_read_int
	movq	%rax, %rcx
	cmpq	$1, %rbx
	jl _block20863
	cmpq	$2, %rbx
	je _block20861
	jmp _block20862

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	pushq	%rbx
	subq	$8, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$8, %rsp
	popq	%rbx
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_99.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Let
  'y
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Prim 'eq? (list (Prim 'read '()) (Int 0)))
    (Int 777)
    (Let 'x (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x))))))
  (Prim '+ (list (Var 'y) (Int 2)))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'y
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Prim 'eq? (list (Prim 'read '()) (Int 0)))
    (Int 777)
    (Let 'x (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x))))))
  (Prim '+ (list (Var 'y) (Int 2)))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'y20866
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Prim 'eq? (list (Prim 'read '()) (Int 0)))
    (Int 777)
    (Let 'x20865 (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x20865))))))
  (Prim '+ (list (Var 'y20866) (Int 2)))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'y20866
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Let 'tmp20867 (Prim 'read '()) (Prim 'eq? (list (Var 'tmp20867) (Int 0))))
    (Int 777)
    (Let 'x20865 (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x20865))))))
  (Prim '+ (list (Var 'y20866) (Int 2)))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons
   'start
   (Seq (Assign (Var 'y20866) (Prim 'read '())) (Goto 'block20868)))
  (cons 'block20868 (Return (Prim '+ (list (Var 'y20866) (Int 2)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20866 . Integer)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20866)))
     (Jmp 'block20868))))
  (cons
   'block20868
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'y20866) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set: #<Var: y20866>>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20866 . Integer)))
 (list
  (cons
   'block20868
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20866) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20866))
      (set (Var 'y20866))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20866)))
     (Jmp 'block20868))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

#<Reg: r11> -> #<Reg: rax>;
#<Reg: rsi> -> #<Reg: rax>;
#<Reg: r10> -> #<Reg: rax>;
#<Reg: r9> -> #<Reg: rax>;
#<Reg: rdi> -> #<Reg: rax>;
#<Reg: rax> -> #<Reg: rdx>;
#<Reg: rax> -> #<Reg: rsi>;
#<Reg: rax> -> #<Reg: r8>;
#<Reg: rax> -> #<Reg: r9>;
#<Reg: rax> -> #<Reg: r11>;
#<Reg: rax> -> #<Reg: r10>;
#<Reg: rax> -> #<Reg: rdi>;
#<Reg: rax> -> #<Reg: rcx>;
#<Reg: r8> -> #<Reg: rax>;
#<Reg: rdx> -> #<Reg: rax>;
#<Reg: rcx> -> #<Reg: rax>;
build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20866 . Integer)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20868
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20866) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20866))
      (set (Var 'y20866))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20866)))
     (Jmp 'block20868))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: y20866>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: y20866> . #<set:>))
old and updated-move-bias: 
((#<Var: y20866> . 0))
((#<Var: y20866> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: y20866> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20866 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20868
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20866))
      (set (Var 'y20866))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Jmp 'block20868))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20868 -> start;
(block20868 start)
removing label:
block20868
(#<Jmp: block20868> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Callq: read_int 0>)
(#<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)>)
(#<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 2> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20866 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20868
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20866))
      (set (Var 'y20866))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20866 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20868
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20866))
      (set (Var 'y20866))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20866 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20868
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20866))
      (set (Var 'y20866))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20868:
	movq	%rcx, %rax
	addq	$2, %rax
	jmp _conclusion

	.align 16
_start:
	callq	_read_int
	movq	%rax, %rcx
	movq	%rcx, %rax
	addq	$2, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


testing @ utilities.rkt:2098
prog-file-name:
"./tests/cond_test_990.rkt"


compile-file: output of type check @ utilities.rkt:2105
tsexp:
(Program
 '()
 (Let
  'y
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Prim 'eq? (list (Prim 'read '()) (Int 0)))
    (Int 777)
    (Let 'x (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x))))))
  (Prim '+ (list (Var 'y) (Int 2)))))


compiling, running pass: shrink @ utilities.rkt:2118

shrink output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'y
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Prim 'eq? (list (Prim 'read '()) (Int 0)))
    (Int 777)
    (Let 'x (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x))))))
  (Prim '+ (list (Var 'y) (Int 2)))))


type checking... @ utilities.rkt:2124

compiling, running pass: uniquify @ utilities.rkt:2118

uniquify output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'y20870
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Prim 'eq? (list (Prim 'read '()) (Int 0)))
    (Int 777)
    (Let 'x20869 (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x20869))))))
  (Prim '+ (list (Var 'y20870) (Int 2)))))


type checking... @ utilities.rkt:2124

compiling, running pass: remove complex opera* @ utilities.rkt:2118

remove complex opera* output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(Program
 '()
 (Let
  'y20870
  (If
   (Bool #t)
   (Prim 'read '())
   (If
    (Let 'tmp20871 (Prim 'read '()) (Prim 'eq? (list (Var 'tmp20871) (Int 0))))
    (Int 777)
    (Let 'x20869 (Prim 'read '()) (Prim '+ (list (Int 1) (Var 'x20869))))))
  (Prim '+ (list (Var 'y20870) (Int 2)))))


type checking... @ utilities.rkt:2124

compiling, running pass: explicate control @ utilities.rkt:2118

explicate control output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(CProgram
 '()
 (list
  (cons
   'start
   (Seq (Assign (Var 'y20870) (Prim 'read '())) (Goto 'block20872)))
  (cons 'block20872 (Return (Prim '+ (list (Var 'y20870) (Int 2)))))))


type checking... @ utilities.rkt:2124

compiling, running pass: instruction selection @ utilities.rkt:2118

instruction selection output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20870 . Integer)))
 (list
  (cons
   'start
   (Block
    '()
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20870)))
     (Jmp 'block20872))))
  (cons
   'block20872
   (Block
    '()
    (list
     (Instr 'movq (list (Var 'y20870) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: liveness analysis @ utilities.rkt:2118

(#<set:>)
(#<set: #<Var: y20870>>)
liveness analysis output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20870 . Integer)))
 (list
  (cons
   'block20872
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20870) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20870))
      (set (Var 'y20870))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20870)))
     (Jmp 'block20872))))))


compiling, running pass: build interference graph @ utilities.rkt:2118

#<Reg: r11> -> #<Reg: rax>;
#<Reg: rsi> -> #<Reg: rax>;
#<Reg: r10> -> #<Reg: rax>;
#<Reg: r9> -> #<Reg: rax>;
#<Reg: rdi> -> #<Reg: rax>;
#<Reg: rax> -> #<Reg: rdx>;
#<Reg: rax> -> #<Reg: rsi>;
#<Reg: rax> -> #<Reg: r8>;
#<Reg: rax> -> #<Reg: r9>;
#<Reg: rax> -> #<Reg: r11>;
#<Reg: rax> -> #<Reg: r10>;
#<Reg: rax> -> #<Reg: rdi>;
#<Reg: rax> -> #<Reg: rcx>;
#<Reg: r8> -> #<Reg: rax>;
#<Reg: rdx> -> #<Reg: rax>;
#<Reg: rcx> -> #<Reg: rax>;
build interference graph output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 '((locals-types (y20870 . Integer)) (conflicts . #<unweighted-graph>))
 (list
  (cons
   'block20872
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Var 'y20870) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20870))
      (set (Var 'y20870))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Var 'y20870)))
     (Jmp 'block20872))))))


compiling, running pass: register allocation @ utilities.rkt:2118

move-graph: move-graph end
cur-node neighbors potential-colors interfering-colors cur-color
#<Var: y20870>
()
#<set:>
#<set:>
0
updated-saturation: ((#<Var: y20870> . #<set:>))
old and updated-move-bias: 
((#<Var: y20870> . 0))
((#<Var: y20870> . 0))
variable-colors: ((#<Reg: rcx> . 0) (#<Reg: rdx> . 1) (#<Reg: rsi> . 2) (#<Reg: rdi> . 3) (#<Reg: r8> . 4) (#<Reg: r9> . 5) (#<Reg: r10> . 6) (#<Reg: r11> . 7) (#<Reg: rbx> . 8) (#<Reg: r12> . 9) (#<Reg: r13> . 10) (#<Reg: r14> . 11) (#<Reg: rax> . -1) (#<Reg: rsp> . -2) (#<Reg: rbp> . -3) (#<Reg: r15> . -4) (#<Var: y20870> . 0))
register allocation output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20870 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20872
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20870))
      (set (Var 'y20870))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Jmp 'block20872))))))


compiling, running pass: remove jumps @ utilities.rkt:2118

block20872 -> start;
(block20872 start)
removing label:
block20872
(#<Jmp: block20872> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Callq: read_int 0>)
(#<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)>)
(#<Callq: read_int 0> #<Instr: movq (#<Reg: rax> #<Reg: rcx>)> #<Instr: movq (#<Reg: rcx> #<Reg: rax>)> #<Instr: addq (#<Imm: 2> #<Reg: rax>)> #<Jmp: conclusion>)
remove jumps output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20870 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20872
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20870))
      (set (Var 'y20870))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: patch instructions @ utilities.rkt:2118

patch instructions output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20870 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20872
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20870))
      (set (Var 'y20870))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))))


compiling, running pass: prelude-and-conclusion @ utilities.rkt:2118

prelude-and-conclusion output:  @ utilities.rkt:2122
(strip-has-type new-p^):
(X86Program
 (list
  '(locals-types (y20870 . Integer))
  '(conflicts . #<unweighted-graph>)
  (cons 'used_callee (set))
  '(stack-space . 0))
 (list
  (cons
   'block20872
   (Block
    (list (list 'live-sets (set (Reg 'rax)) (set) (set)))
    (list
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'start
   (Block
    (list
     (list
      'live-sets
      (set (Reg 'rax))
      (set (Var 'y20870))
      (set (Var 'y20870))))
    (list
     (Callq 'read_int 0)
     (Instr 'movq (list (Reg 'rax) (Reg 'rcx)))
     (Instr 'movq (list (Reg 'rcx) (Reg 'rax)))
     (Instr 'addq (list (Imm 2) (Reg 'rax)))
     (Jmp 'conclusion))))
  (cons
   'main
   (Block
    '()
    (list
     (Instr 'pushq (list (Reg 'rbp)))
     (Instr 'movq (list (Reg 'rsp) (Reg 'rbp)))
     (Instr 'subq (list (Imm 0) (Reg 'rsp)))
     (Jmp 'start))))
  (cons
   'conclusion
   (Block
    '()
    (list
     (Instr 'addq (list (Imm 0) (Reg 'rsp)))
     (Instr 'popq (list (Reg 'rbp)))
     (Retq))))))


x86 output:
	.align 16
_block20872:
	movq	%rcx, %rax
	addq	$2, %rax
	jmp _conclusion

	.align 16
_start:
	callq	_read_int
	movq	%rax, %rcx
	movq	%rcx, %rax
	addq	$2, %rax
	jmp _conclusion

	.globl _main
	.align 16
_main:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$0, %rsp
	jmp _start

	.align 16
_conclusion:
	addq	$0, %rsp
	popq	%rbp
	retq


20 success(es) 0 failure(s) 0 error(s) 20 test(s) run
0
